# bot.py
import logging
import sqlite3
from telegram.ext import Application, CommandHandler, ContextTypes, JobQueue
from telegram import Update
import ccxt
import os
from contextlib import contextmanager

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# === –ù–ê–°–¢–†–û–ô–ö–ò ===
TOKEN = os.getenv("TELEGRAM_TOKEN")
if not TOKEN:
    raise ValueError("–¢—Ä–µ–±—É–µ—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_TOKEN")

THRESHOLD = 1.5  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Ä–∞–∑–Ω–∏—Ü–∞ –≤ %
symbols = ['BTC/USDT', 'ETH/USDT']

# –ë–∏—Ä–∂–∏
exchanges = {
    'binance': ccxt.binance(),
    'bybit': ccxt.bybit(),
    'kucoin': ccxt.kucoin(),
}

# –ü—É—Ç—å –∫ –ë–î (Render –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–∏—Å–∞—Ç—å —Ç–æ–ª—å–∫–æ –≤ /tmp)
DB_PATH = '/tmp/users.db'

# === –ö–û–ù–¢–ï–ö–°–¢–ù–´–ô –ú–ï–ù–ï–î–ñ–ï–† –î–õ–Ø –ë–î ===
@contextmanager
def get_db():
    conn = sqlite3.connect(DB_PATH, timeout=10)
    try:
        yield conn
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

# === –†–ê–ë–û–¢–ê –° –ë–ê–ó–û–ô –î–ê–ù–ù–´–• ===
def init_db():
    try:
        with get_db() as conn:
            c = conn.cursor()
            c.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    username TEXT,
                    is_premium INTEGER DEFAULT 0,
                    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.commit()
            logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î: {e}")

def add_user(user_id: int, username: str):
    try:
        with get_db() as conn:
            c = conn.cursor()
            c.execute('''
                INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)
            ''', (user_id, username))
            conn.commit()
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}")

def is_premium(user_id: int) -> bool:
    try:
        with get_db() as conn:
            c = conn.cursor()
            c.execute('SELECT is_premium FROM users WHERE user_id = ?', (user_id,))
            row = c.fetchone()
            return bool(row[0]) if row else False
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–µ–º–∏—É–º–∞ –¥–ª—è {user_id}: {e}")
        return False

def set_premium(user_id: int):
    try:
        with get_db() as conn:
            c = conn.cursor()
            c.execute('UPDATE users SET is_premium = 1 WHERE user_id = ?', (user_id,))
            conn.commit()
            logger.info(f"üéâ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} —Å—Ç–∞–ª Premium")
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ Premium –¥–ª—è {user_id}: {e}")

# === –ê–õ–ï–†–¢: –ê–†–ë–ò–¢–†–ê–ñ ===
async def check_arbitrage(context: ContextTypes.DEFAULT_TYPE):
    job = context.job
    user_id = job.user_id

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—Å—ë –µ—â—ë –ø—Ä–µ–º–∏—É–º
    if not is_premium(user_id):
        logger.info(f"üö´ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {user_id} –±–æ–ª—å—à–µ –Ω–µ Premium ‚Äî –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–ª–µ—Ä—Ç—ã")
        context.job.schedule_removal()
        return

    for symbol in symbols:
        prices = {}
        for name, exchange in exchanges.items():
            try:
                ticker = exchange.fetch_ticker(symbol)
                if ticker and 'last' in ticker:
                    prices[name] = ticker['last']
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É —Å {name}: {e}")

        if len(prices) < 2:
            continue

        min_price = min(prices.values())
        max_price = max(prices.values())
        spread = (max_price - min_price) / min_price * 100

        if spread > THRESHOLD:
            min_ex = [k for k, v in prices.items() if v == min_price][0]
            max_ex = [k for k, v in prices.items() if v == max_price][0]

            message = f"""
üö® **–ê–†–ë–ò–¢–†–ê–ñ –û–ë–ù–ê–†–£–ñ–ï–ù** ({symbol})
üìâ –î–µ—à–µ–≤–ª–µ: {min_ex.upper()} ‚Äî ${min_price:,.2f}
üìà –î–æ—Ä–æ–∂–µ: {max_ex.upper()} ‚Äî ${max_price:,.2f}
üìä –†–∞–∑–Ω–∏—Ü–∞: **{spread:.2f}%**
üïí {context.job.next_t.strftime('%H:%M:%S')}
üîó [–ö—É–ø–∏—Ç—å –Ω–∞ {min_ex}]({exchanges[min_ex].urls['www']})
            """
            try:
                await context.bot.send_message(
                    chat_id=user_id,
                    text=message.strip(),
                    parse_mode='Markdown',
                    disable_web_page_preview=False
                )
                logger.info(f"‚úÖ –ê–ª–µ—Ä—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω {user_id}: {spread:.2f}% –Ω–∞ {symbol}")
            except Exception as e:
                logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å {user_id}: {e}")
                if "blocked" in str(e).lower() or "kicked" in str(e).lower():
                    context.job.schedule_removal()

# === –ö–û–ú–ê–ù–î–´ ===
async def start(update: Update, context):
    user = update.effective_user
    add_user(user.id, user.username)
    await update.message.reply_text(
        f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n\n"
        "–Ø ‚Äî **ArbHunterBot**. –°–ª–µ–∂—É –∑–∞ —Ü–µ–Ω–∞–º–∏ –Ω–∞ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã –∏ –ø—Ä–∏—Å—ã–ª–∞—é —Å–∏–≥–Ω–∞–ª—ã –∞—Ä–±–∏—Ç—Ä–∞–∂–∞.\n\n"
        "üîπ /prices ‚Äî —Ç–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã\n"
        "üî∏ /subscribe ‚Äî —Ç–∞—Ä–∏—Ñ—ã\n"
        "üíé /premium ‚Äî –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å Premium (–≤—Ä–µ–º–µ–Ω–Ω–æ –±–µ—Å–ø–ª–∞—Ç–Ω–æ)"
    )

async def prices(update: Update, context):
    reply = "üìä –¢–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã:\n\n"
    for symbol in symbols:
        reply += f"**{symbol}**\n"
        for name, exchange in exchanges.items():
            try:
                price = exchange.fetch_ticker(symbol)['last']
                reply += f"  {name}: ${price:,.2f}\n"
            except Exception as e:
                reply += f"  {name}: –æ—à–∏–±–∫–∞\n"
        reply += "\n"
    await update.message.reply_text(reply.strip(), parse_mode='Markdown')

async def subscribe(update: Update, context):
    text = """
üíé **Premium –ø–æ–¥–ø–∏—Å–∫–∞** ‚Äî $9.99/–º–µ—Å

‚úÖ –ê–ª–µ—Ä—Ç—ã –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥  
‚úÖ –í—Å–µ –º–æ–Ω–µ—Ç—ã –∏ –±–∏—Ä–∂–∏  
‚úÖ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞  
‚úÖ API –¥–æ—Å—Ç—É–ø (—Å–∫–æ—Ä–æ)

üëâ –ü–æ–∫–∞ —á—Ç–æ –∞–∫—Ç–∏–≤–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ **–±–µ—Å–ø–ª–∞—Ç–Ω–∞** —á–µ—Ä–µ–∑ /premium
    """
    await update.message.reply_text(text.strip(), parse_mode='Markdown')

async def premium(update: Update, context):
    user_id = update.effective_user.id

    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–¥–∞—á–∏
    job_name = f"arb_alert_{user_id}"
    current_jobs = context.job_queue.get_jobs_by_name(job_name)
    for job in current_jobs:
        job.schedule_removal()

    # –î–∞—ë–º –ø—Ä–µ–º–∏—É–º
    set_premium(user_id)

    # –ó–∞–ø—É—Å–∫–∞–µ–º –∞–ª–µ—Ä—Ç—ã
    context.job_queue.run_repeating(
        check_arbitrage,
        interval=15,
        first=5,
        name=job_name,
        user_id=user_id
    )

    await update.message.reply_text(
        "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã ‚Äî **Premium –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å**!\n"
        "–¢–µ–ø–µ—Ä—å —Ç—ã –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å –∞–ª–µ—Ä—Ç—ã –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥.\n\n"
        "–ß—Ç–æ–±—ã –æ—Ç–∫–ª—é—á–∏—Ç—å ‚Äî –Ω–∞–ø–∏—à–∏ /stop"
    )

async def stop(update: Update, context):
    user_id = update.effective_user.id
    job_name = f"arb_alert_{user_id}"
    jobs = context.job_queue.get_jobs_by_name(job_name)
    for job in jobs:
        job.schedule_removal()
    await update.message.reply_text("üõë –ê–ª–µ—Ä—Ç—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã.")

# === –ó–ê–ü–£–°–ö ===
def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
    init_db()

    # –°–æ–∑–¥–∞—ë–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    try:
        app = Application.builder().token(TOKEN).build()
        logger.info("ü§ñ –ë–æ—Ç: —Ç–æ–∫–µ–Ω –∑–∞–≥—Ä—É–∂–µ–Ω")
    except Exception as e:
        logger.critical(f"‚ùå –û—à–∏–±–∫–∞ —Ç–æ–∫–µ–Ω–∞: {e}")
        raise

    # –•—ç–Ω–¥–ª–µ—Ä—ã
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("prices", prices))
    app.add_handler(CommandHandler("subscribe", subscribe))
    app.add_handler(CommandHandler("premium", premium))
    app.add_handler(CommandHandler("stop", stop))

    # –ó–∞–ø—É—Å–∫
    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    app.run_polling()

if __name__ == '__main__':
    main()
